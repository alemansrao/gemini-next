
// New chat page (fresh session)
// /app/page.jsx
'use client';

import ChatView from './components/ChatView';

export default function Page() {
return <ChatView />;
}



// /components/ChatView.jsx
'use client';

import { useEffect, useRef, useState } from 'react';
import { addToast, Textarea, Spinner, Button } from '@heroui/react';
import { MdSend } from 'react-icons/md';
import { LuClipboardPaste } from 'react-icons/lu';
import ReactMarkdown from 'react-markdown';
import NavbarComponent from '../components/Navbar';
import { v4 as uuidv4 } from 'uuid';

import {
addMessage,
createChat,
getChat,
getMessages,
upsertChatTitle,
touchChat,
} from '../lib/db';

import Sidebar from '../components/Sidebar';

import {
updateHasScrollbar,
createScrollHandler,
setupResizeObserver,
scrollToTop as helperScrollToTop,
DEFAULT_MESSAGES,
API_KEY_STORAGE_KEY,
MODEL_STORAGE_KEY,
} from '../helpers/chatHelpers';

import { useRouter } from 'next/navigation';

export default function ChatView({ existingChatId = null }) {
const router = useRouter();

// --- State ---
const [chatId, setChatId] = useState(existingChatId ?? '');
const [chatTitle, setChatTitle] = useState('');
const [input, setInput] = useState('');
const [messages, setMessages] = useState(DEFAULT_MESSAGES);
const [loading, setLoading] = useState(false);
const [firstTurn, setFirstTurn] = useState(false);

const isBrowser = typeof window !== 'undefined';
const initialModel =
isBrowser ? localStorage.getItem(MODEL_STORAGE_KEY) ?? 'gemini-2.5-flash' : 'gemini-2.5-flash';
const [model, setModel] = useState(initialModel);

const messagesRef = useRef(null);

// Guard to prevent duplicate initialization in Strict Mode
const initRef = useRef(null);

// --- Initialization: new or existing chat ---
useEffect(() => {
(async () => {
try {
// Normalize existingChatId (can be undefined/null)
const targetId = existingChatId ?? null;
console.log('ChatView init, targetId:', existingChatId);
if (targetId) {
// Prevent re-initializing the same existing chat on Strict Mode double-render
if (initRef.current === targetId) return;
initRef.current = targetId;

const chat = await getChat(targetId);
if (!chat) {
addToast({
title: 'Not found',
description: 'Chat no longer exists',
color: 'warning',
});
router.push('/');
return;
}

const msgs = await getMessages(targetId);
setMessages(msgs.length ? msgs : DEFAULT_MESSAGES);
setChatId(targetId);
setChatTitle(chat.title ?? '');
setModel(chat.model ?? model);
// Existing chats should not regenerate title
setFirstTurn(false);
} else {
// New chat flow, initialize only once per mount
if (initRef.current === 'new') return;
initRef.current = 'new';

const id = uuidv4();
setChatId(id);
console.log('Creating new chat with id', id);
await createChat({ id, model });

// Seed initial scripted messages into store + local state for continuity
for (const m of DEFAULT_MESSAGES) {
await addMessage({ chatId: id, role: m.role, content: m.content });
}
setMessages(DEFAULT_MESSAGES);
setFirstTurn(true);
}
} catch (e) {
console.error(e);
addToast({
title: 'Init failed',
description: 'Could not initialize chat',
color: 'danger',
});
}
})();
// eslint-disable-next-line react-hooks/exhaustive-deps
}, [existingChatId]);






async function fetchChatTitle(apiKey, message) {
try {
const res = await fetch('/api/title', {
method: 'POST',
headers: { 'Content-Type': 'application/json' },
body: JSON.stringify({ message, apiKey }),
});
if (!res.ok) {
const txt = await res.text().catch(() => '');
throw new Error(`Title API error (${res.status}): ${txt || 'Unknown error'}`);
}
const data = await res.json();
// Accept both {title} and legacy {chatTitle}
const title = data.title ?? data.chatTitle ?? '';
return title ?? '';
} catch (e) {
console.error('fetchChatTitle failed:', e);
return '';
}
}

async function sendMessage() {
const apiKey = isBrowser ? localStorage.getItem(API_KEY_STORAGE_KEY) : null;
const selectedModel = isBrowser
? localStorage.getItem(MODEL_STORAGE_KEY) ?? model
: model;
const systemPrompt = isBrowser ? localStorage.getItem('systemPrompt') ?? '' : '';

if (!input.trim()) return;

if (!apiKey) {
addToast({
title: 'API Key Missing',
description: 'Add your Gemini API key in Settings.',
color: 'warning',
});
router.push('/settings');
return;
}

const userMsg = { role: 'user', content: input.trim() };
setInput('');
setLoading(true);

try {
// Display & persist user message
setMessages((prev) => [...prev, userMsg]);
await addMessage({ chatId, role: 'user', content: userMsg.content });

// Generate title on first user turn (background)
if (firstTurn) {
setFirstTurn(false);
fetchChatTitle(apiKey, userMsg.content)
.then(async (title) => {
const t =
title ||
(userMsg.content.length > 48
? userMsg.content.slice(0, 48) + '...'
: userMsg.content);
setChatTitle(t);
await upsertChatTitle(chatId, t);
})
.catch(() => { });
}

// Build payload history using current messages + new user message
const history = [...messages, userMsg];

const res = await fetch('/api/chat', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'x-gemini-api-key': apiKey,
},
body: JSON.stringify({
messages: history,
model: selectedModel ?? 'gemini-2.5-flash',
systemPrompt: systemPrompt || undefined,
}),
});

const data = await res.json().catch(() => ({}));
if (!res.ok || !data) {
throw new Error(
data?.error ?? `Chat API error (${res.status}): ${JSON.stringify(data)}`
);
}

const reply = (data.reply ?? '').toString();
if (!reply) throw new Error('Empty model reply');

const assistant = { role: 'model', content: reply };
setMessages((prev) => [...prev, assistant]);
await addMessage({ chatId, role: 'model', content: reply });
await touchChat(chatId);
} catch (e) {
console.error(e);
const errText =
'Something went wrong. Please check your API key, model, or try again.';
setMessages((prev) => [...prev, { role: 'model', content: errText }]);
await addMessage({ chatId, role: 'model', content: errText });
addToast({ title: 'Request failed', description: String(e), color: 'danger' });
} finally {
setLoading(false);
}
}

// Hide the first message only if it's the seeded "system" message
const displayedMessages =
messages[0]?.role === 'system' ? messages.slice(1) : messages;

return (
<div className="flex h-screen bg-base-200">
{/* Sidebar (hidden on mobile) */}
<Sidebar currentChatId={chatId} />

{/* Main column */}
<div className="flex flex-col flex-1 min-w-0">
<NavbarComponent chattitle={chatTitle} />

{/* Chat header (mobile) */}


{/* Messages */}
<div
className="flex-1 overflow-y-auto space-y-4 px-3 md:px-10 py-3"
>
{displayedMessages.map((msg, index) => (
<div
key={index}
className={`chat gap-0 md:gap-1.5 ${msg.role === 'user' ? 'chat-end' : 'chat-start'}`}
>
{msg.role === 'model' && (
<div className="chat-image avatar">
<div className="w-6 md:w-10 rounded-full">
<img
onClick={() => {
navigator.clipboard.writeText(msg.content);
addToast({ title: 'Copied', color: 'success' });
}}
alt="assistant"
src="/gemini_logo.png"
/>
</div>
</div>
)}

{msg.role === 'user' && (
<div className="chat-image ml-1 avatar">
<div className="w-6 md:w-10 rounded-full border border-white md:p-2 p-1">
<img
alt="user"
onClick={() => {
navigator.clipboard.writeText(msg.content);
addToast({ title: 'Copied', color: 'success' });
}}
src="/user.png"
style={{ filter: 'invert(1)' }}
/>
</div>
</div>
)}

<div
className={`chat-bubble rounded-4xl whitespace-pre-wrap ${msg.role === 'user'
? 'bg-primary text-primary-content max-w-4/5 md:max-w-3/5'
: 'text-content1 max-w-4/5 md:max-w-3/5 selection:bg-yellow-400'
}`}
>
<ReactMarkdown>{msg.content}</ReactMarkdown>
</div>
</div>
))}

{loading && (
<div className="chat chat-start">
<div className="chat-image avatar">
<div className="w-10 rounded-full">
<img
onClick={() => {
navigator.clipboard.writeText(msg.content);
addToast({ title: 'Copied', color: 'success' });
}}
alt="assistant"
src="/gemini_logo.png"
/>
</div>
</div>
<div className="chat-bubble rounded-4xl text-content1 max-w-4/5 md:max-w-3/5 selection:bg-yellow-400">
<div className="flex items-center gap-2">
<span>Thinkingâ€¦</span>
<Spinner size="sm" />
</div>
</div>
</div>
)}
</div>

{/* Input */}
<div className="p-4 flex items-center gap-3 md:px-10">
<Textarea
label="Prompt"
variant="flat"
className="dark"
onChange={(e) => setInput(e.target.value)}
value={input}
maxRows={4}
placeholder="Enter your prompt..."
onKeyDown={(e) => {
if (e.key === 'Enter' && !e.shiftKey && !loading) {
e.preventDefault();
if (input.trim()) sendMessage();
}
}}
/>
{!input ? (
<LuClipboardPaste
onClick={async () => {
try {
const text = await navigator.clipboard.readText();
setInput(text);
} catch {
addToast({
title: 'Clipboard blocked',
description: 'Grant clipboard permission or paste manually.',
color: 'warning',
});
}
}}
color="black"
className="btn rounded-full bg-amber-400 h-14 w-14"
/>
) : (
<MdSend
color="black"
className={`btn rounded-full bg-amber-400 h-14 w-14 ${loading ? 'opacity-50' : ''
}`}
onClick={() => !loading && sendMessage()}
/>
)}
</div>
</div>
</div>
);
}


'use client';

import React, { useEffect, useState } from "react";
import {
Navbar,
NavbarBrand,
NavbarContent,
NavbarItem,
NavbarMenuToggle,
NavbarMenu,
NavbarMenuItem,
Link,
Button,
Spinner,
addToast,
} from "@heroui/react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { listChats, deleteChat } from "../lib/db";
import { MdDelete } from "react-icons/md";

export const AcmeLogo = () => (
<Image
src="/gemini.png"
alt="Gemini Logo"
width={100}
height={50}
priority
/>
);

export default function NavbarComponent({ chattitle, currentChatId }) {
const [isMenuOpen, setIsMenuOpen] = useState(false);
const [chats, setChats] = useState(null);
const router = useRouter();

async function loadChats() {
const rows = await listChats();
setChats(rows);
}

useEffect(() => {
loadChats();
}, []);

return (
<Navbar onMenuOpenChange={setIsMenuOpen}>
<NavbarContent>
<NavbarMenuToggle className="md:hidden" />
<NavbarBrand>
<Link href="/"><AcmeLogo /></Link>
</NavbarBrand>
</NavbarContent>

{/* Center title (desktop) */}
<NavbarContent className="hidden sm:flex" justify="center">
<NavbarItem>{chattitle}</NavbarItem>
</NavbarContent>

{/* Right */}
<NavbarContent justify="end">
<NavbarItem>
<Button as={Link} color="primary" href="/settings" variant="bordered">
Settings
</Button>
</NavbarItem>
</NavbarContent>

{/* Mobile menu = chat list */}
<NavbarMenu>
{!chats ? (
<div className="flex justify-center py-6">
<Spinner size="sm" />
</div>
) : chats.length === 0 ? (
<p className="text-center text-default-500 py-6">No chats</p>
) : (
chats.map((chat) => (
<NavbarMenuItem
key={chat.id}
className={`flex justify-between items-center gap-2 ${chat.id === currentChatId ? "bg-primary/20 rounded-lg" : ""
}`}
>
<Link
className="flex-1 truncate"
onPress={() => {
router.push(`/chat/${chat.id}`);
setIsMenuOpen(false);
}}
>
{chat.title?.slice(0, 25) || "New chat"}
{' - '}
{new Date(chat.updatedAt).toLocaleString('en-US', {
month: 'short',   // Dec
day: '2-digit',   // 31
hour: '2-digit',  // 17
minute: '2-digit',// 30
hour12: false     // 24-hour time
}).replace(',', '')
}

</Link>

<Button
isIconOnly
size="sm"
variant="light"
color="danger"
onPress={async () => {
addToast({ title: 'Deleted', color: 'warning' });
await deleteChat(chat.id);
loadChats();
}}
>
<MdDelete size={16} />
</Button>
</NavbarMenuItem>
))
)}
</NavbarMenu>
</Navbar>
);
}





// Sidebar to browse chats
// /components/Sidebar.jsx
'use client';
import { Card, CardHeader, CardBody, CardFooter, Divider, Link, Image } from "@heroui/react";
import { useEffect, useState } from 'react';
import { listChats, deleteChat, deleteAllChats, deleteNoTitleChats } from '../lib/db';
import { useRouter } from 'next/navigation';
import { addToast, Button, Input, Spinner } from '@heroui/react';
import { MdAdd, MdDelete, MdSettings } from 'react-icons/md';

export default function Sidebar({ currentChatId }) {
const router = useRouter();
const [chats, setChats] = useState(null);
const [filter, setFilter] = useState('');

async function load() {
try {
const rows = await listChats();
setChats(rows);
} catch (e) {
console.error(e);
addToast({ title: 'Load failed', description: 'Could not load chat list', color: 'danger' });
}
}

useEffect(() => {
load();
const id = setInterval(load, 1500); // lightweight polling for live updates (Dexie liveQuery alt.)
return () => clearInterval(id);
}, []);

const filtered = (chats || []).filter((c) =>
(c.title || '(no title)').toLowerCase().includes(filter.toLowerCase()),
);

return (
<aside className="w-72 shrink-0 border-r border-neutral-800 bg-base-200 hidden md:flex md:flex-col py-3">


<div className="px-3 pb-2">
<Input
placeholder="Search chats..."
value={filter}
onChange={(e) => setFilter(e.target.value)}
size="sm"
/>
</div>

<div className="flex-1 overflow-y-auto">
{!chats ? (
<div className="flex items-center justify-center h-full">
<Spinner size="sm" color="default" />
</div>
) : filtered.length === 0 ? (
<p className="text-center text-content3 px-3 py-8">No chats yet</p>
) : (
<>
<Card className={`max-w-[400px] dark cursor-pointer`}>
<CardHeader className="flex  gap-3 justify-end">
<Button
onPress={async () => {
deleteNoTitleChats();

addToast({ title: 'Deleted all empty chats', color: 'danger' });
}}
className="opacity-60 hover:opacity-100 p-1 px-3 hover:bg-zinc-200 rounded-3xl bg-zinc-700 hover:text-danger">Testing</Button>
<Button
className="opacity-60 hover:opacity-100 p-1 px-3 hover:bg-zinc-200 rounded-3xl bg-zinc-700 hover:text-danger"
onPress={async () => {
const ok = window.confirm(
'Delete all chats? This action cannot be undone.'
);
if (!ok) {
addToast({ title: 'Deletion cancelled', color: 'success' });
return;
}

await deleteAllChats();
addToast({ title: 'Deleted all chats', color: 'danger' });
await load();
}}
title="Delete chat"
>
Delete All <MdDelete size={18} />
</Button>

</CardHeader>
</Card>
{filtered.map((chat) => (
<Card key={chat.id} className={`max-w-[400px] dark cursor-pointer  ${chat.id === currentChatId ? 'bg-primary/20' : 'hover:bg-gray-800'}`}>
<CardHeader className="flex gap-3 justify-between " onClick={() => router.push(`/chat/${chat.id}`)}>
<div className="flex flex-col">
<p className="text-md">{chat.title.slice(0, 15).trim() || 'New chat'}</p>
<p className="text-small text-default-500">{new Date(chat.updatedAt).toLocaleString()}</p>
</div>
<Button
className="opacity-60 hover:opacity-100 p-1 hover:bg-zinc-200 rounded-3xl bg-zinc-700 hover:text-danger"
onPress={async () => {
await deleteChat(chat.id);
addToast({ title: 'Deleted', color: 'warning' });
load();
if (chat.id === currentChatId) router.push('/');
}}
title="Delete chat"
>
<MdDelete size={18} />
</Button>
</CardHeader>
</Card>

))}
</>
)}
</div>
</aside>
);
}



//app/layout.jsx

import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

import { Providers } from "./providers";
const geistSans = Geist({
variable: "--font-geist-sans",
subsets: ["latin"],
});

const geistMono = Geist_Mono({
variable: "--font-geist-mono",
subsets: ["latin"],
});

export const metadata = {
title: "Gemini Chatbot using Next.js",
description: "Gemini frontend using Next.js and HeroUI with customizable system prompts.",
};

export default function RootLayout({ children }) {
return (
<html lang="en">
<body
className={`${geistSans.variable} ${geistMono.variable} antialiased`}
>
<Providers themeProps={{ attribute: "class", defaultTheme: "dark" }}>
{children}</Providers>
</body>
</html>

);
}




"use client";
import { useState, useEffect } from "react";
import { TbPrompt } from "react-icons/tb";
import Image from "next/image";
import { Input, Button, Card, addToast, Textarea } from "@heroui/react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import NavbarComponent from "../components/Navbar";
export default function SettingsPage() {
const router = useRouter();

const [apiKey, setApiKey] = useState("");
const [systemPrompt, setSystemPrompt] = useState("");
const [selectedModel, setSelectedModel] = useState("gemini-2.5-flash-lite"); // Default model
const [mounted, setMounted] = useState(false);

// Load data from localStorage on mount
useEffect(() => {
const storedApiKey = localStorage.getItem("geminiApiKey") || "";
setApiKey(storedApiKey);

const storedSystemPrompt = localStorage.getItem("systemPrompt") || "";
setSystemPrompt(storedSystemPrompt);

const storedSelectedModel = localStorage.getItem("selectedModel") || "gemini-2.5-flash-lite";
setSelectedModel(storedSelectedModel);

setMounted(true);
}, []);

// Handlers for API Key
const handleApiKeyChange = (e) => {
const value = e.target.value;
setApiKey(value);
if (typeof window !== "undefined") {
localStorage.setItem("geminiApiKey", value);
}
};

const handleSaveApiKey = () => {
addToast({
title: "API Key Saved",
color: "success",
description: "Gemini API key saved to local storage.",
});
};

const handleClearApiKey = () => {
setApiKey("");
if (typeof window !== "undefined") {
localStorage.removeItem("geminiApiKey");
}
addToast({
title: "API Key Removed",
color: "warning",
description: "Gemini API key removed from local storage.",
});
};

// Handlers for System Prompt
const handleSystemPromptChange = (e) => {
const value = e.target.value;
setSystemPrompt(value);
if (typeof window !== "undefined") {
localStorage.setItem("systemPrompt", value);
}
};

const handleTestPrompt = () => {
// Placeholder for actual prompt testing logic
addToast({
title: "Prompt Test Initiated",
color: "success",
description: "This feature is under development.",
});
};

const handleClearPrompt = () => {
setSystemPrompt("");
if (typeof window !== "undefined") {
localStorage.removeItem("systemPrompt");
}
addToast({
title: "System Prompt Cleared",
color: "warning",
description: "System prompt cleared from local storage.",
});
};

// Handlers for Model Configuration
const handleModelChange = (e) => {
const value = e.target.value;
setSelectedModel(value);
if (typeof window !== "undefined") {
localStorage.setItem("selectedModel", value);
}
};

const handleApplyModelConfig = () => {
addToast({
title: "Model Configuration Applied",
color: "success",
description: "Your model settings have been updated.",
});
};

const handleResetModelConfig = () => {
setSelectedModel("gemini-pro"); // Reset to default
if (typeof window !== "undefined") {
localStorage.setItem("selectedModel", "gemini-pro");
}
addToast({
title: "Model Configuration Reset",
color: "warning",
description: "Model settings have been reset to default.",
});
};

return (
<>
<NavbarComponent />
<div className="p-8 bg-base-200 min-h-screen">
<div className="grid grid-cols-1 lg:grid-cols-2 gap-6 max-w-7xl mx-auto">
{/* System Prompt Section */}
<div className="lg:col-span-1 row-span-1 lg:row-span-2 flex flex-col">
<Card className="flex-1 bg-base-100 rounded-xl p-6 flex flex-col gap-4">
<div className="flex justify-between items-center">
<div className="flex flex-col">
<h3 className="text-2xl font-semibold">System Prompt</h3>
<p className="text-sm text-base-content/60">
Set your system prompt to tailor fit model responses according to your requirements.
</p>
</div>
<TbPrompt size={32} className="text-primary" />
</div>
<div className="grow">
<Textarea
placeholder="Enter your system prompt here..."
value={systemPrompt}
onChange={handleSystemPromptChange}
className="w-full h-full resize-none rounded-lg p-4"
/>
</div>
<div className="flex flex-row gap-3">
<Button onPress={handleTestPrompt} className="btn-primary">Test Prompt</Button>
<Button onPress={handleClearPrompt} className="btn-outline">Clear Prompt</Button>
</div>
</Card>
</div>

{/* API Key Settings Section (Top Card) */}
<div className="lg:col-span-1 row-span-1">
<Card className="w-full bg-base-100 rounded-xl p-6">
<h2 className="text-2xl font-semibold mb-4">API Key Settings</h2>
<p className="text-sm text-base-content/60 mb-6">
Set your Gemini API key below. This value is stored locally in your browser.
</p>
<div className="mb-4">
<label className="block text-sm font-medium mb-2">Gemini API Key</label>
<Input
placeholder="Enter Gemini API key"
value={apiKey}
onChange={handleApiKeyChange}
className="w-full text-black"
type="password" // Mask the API key
/>
</div>
<div className="flex gap-3">
<Button onPress={handleSaveApiKey} className="btn-primary" disabled={!mounted}>
Save
</Button>
<Button onPress={handleClearApiKey} color="danger" className="btn-outline" disabled={!mounted}>
Clear
</Button>
</div>
</Card>
</div>

{/* Model Configuration Section (Bottom Card) */}
<div className="lg:col-span-1 row-span-1">
<Card className="w-full bg-base-100 rounded-xl p-6">
<h2 className="text-2xl font-semibold mb-4">Model Configuration</h2>
<p className="text-sm text-base-content/60 mb-6">
Configure your preferred model and its parameters.
</p>
<div className="mb-4">
<label className="block text-sm font-medium mb-2">Select Model</label>
<Input
placeholder="e.g., gemini-pro"
value={selectedModel}
onChange={handleModelChange}
className="w-full text-content1"
/>
</div>
<div className="flex gap-3">
<Button onPress={handleApplyModelConfig} className="btn-primary">Apply</Button>
<Button onPress={handleResetModelConfig} className="btn-outline">Reset</Button>
</div>
</Card>
</div>
</div>
</div>
</>
);
}


"use client";
// app/providers.jsx
import { ToastProvider } from "@heroui/toast";
import * as React from "react";
import { HeroUIProvider } from "@heroui/system";
import { useRouter } from "next/navigation";



export function Providers({ children, themeProps }) {
const router = useRouter();

return (
<HeroUIProvider navigate={router.push}>
<ToastProvider placement="top-right" />
{children}
</HeroUIProvider>
);
}


//I need the UI of this whole side to be like CHATGPT
//Add File upload feature in chat
//In intividual chat, have settings to enable searchGrounding,Filesearch