//api/chat/route.js
import { GoogleGenAI } from "@google/genai";

export async function POST(request) {
  try {
    const GEMINI_API_KEY = request.headers.get("x-gemini-api-key");
    if (!GEMINI_API_KEY) {
      return Response.json({ error: "API key missing" }, { status: 401 });
    }

    const { messages, model } = await request.json();
    if (!Array.isArray(messages) || messages.length === 0) {
      return Response.json({ error: "messages must be a non-empty array" }, { status: 400 });
    }

    const modelName = model || "gemini-2.5-flash-lite";
    console.log("chat/Route.js Using model:", modelName);
    // Initialize SDK
    const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });

    // Create chat session
    const chat = ai.chats.create({
      model: modelName,
      history: messages.map(msg => ({
        role: msg.role,
        parts: [{ text: msg.content }],
      })),
    });

    // Send last message
    const lastMessage = messages[messages.length - 1].content;
    //add fake delay if environment variable ENVIRONMENT is found
    if (process.env.ENVIRONMENT) {
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    const response = await chat.sendMessage({ message: lastMessage });

    return Response.json({ reply: response.text });
  } catch (err) {
    console.error("Internal error:", err);
    return Response.json({ reply: "Internal server error" + err });
  }
}










//api/title/route.js
export async function POST(req) {
  // Read incoming body  { message }
  let body;
  try {
    body = await req.json();
  } catch {
    body = {};
  }

  const firstMessage = body.message;


  if (!firstMessage) {
    return new Response(JSON.stringify({ error: "First message is required" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  const systemPrompt =
    "You are to act as a generator for chat titles. The user will send a query - you must generate a title for the chat based on it. Only reply with the short title, nothing else.";

  const payload = {
    messages: [
      { role: "model", content: systemPrompt },
      { role: "user", content: firstMessage },
    ],
  };

  try {
    const chatUrl = new URL("/api/chat", req.url).toString();
    const headers = { "Content-Type": "application/json" };

    // forward apiKey if provided (optional)
    if (body.apiKey) {
      headers["x-gemini-api-key"] = body.apiKey;
    };

    headers['x-gemini-model'] = 'gemini-2.5-flash-lite';
    //logging the request
    console.log("Chat API Request:");
    console.log("URL:", chatUrl);
    console.log("Headers:", headers);
    console.log("Payload:", payload);


    const res = await fetch(chatUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
    });

    if (!res.ok) {
      const txt = await res.text().catch(() => "");
      return new Response(JSON.stringify({ error: "Upstream chat API error", details: txt }), {
        status: 502,
        headers: { "Content-Type": "application/json" },
      });
    }

    const data = await res.json().catch(() => null);

    // Try common response shapes to extract assistant text
    let assistantReply = data.reply || "New Chat";

    if (!assistantReply && typeof data === "string") assistantReply = data;

    if (!assistantReply) {
      return new Response(JSON.stringify({ error: "No title returned from chat API" }), {
        status: 502,
        headers: { "Content-Type": "application/json" },
      });
    }

    assistantReply = String(assistantReply).trim().split("\n")[0].replace(/^["']|["']$/g, "").trim();

    return new Response(JSON.stringify({ title: assistantReply }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (err) {
    return new Response(JSON.stringify({ error: "Internal error", details: String(err) }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
}














// app/components/Navbar.jsx
import React from "react";
import {
	Navbar,
	NavbarBrand,
	NavbarContent,
	NavbarItem,
	NavbarMenuToggle,
	NavbarMenu,
	NavbarMenuItem,
	Link,
	Button,
} from "@heroui/react";
import Image from "next/image";
import { warning } from "framer-motion";

export const AcmeLogo = () => {
	return (
		<Image
			src="/gemini.png"
			alt="Gemini Logo"
			width={100}
			height={50}
			priority   // ensures eager loading for LCP images
            loading="eager"
		/>
	);
};

export default function NavbarComponent({ chattitle }) {
	const [isMenuOpen, setIsMenuOpen] = React.useState(false);
	const menuItems = [
		{ 'name': 'Chat title blah blah blah blah', 'href': '/settings' },
		// {'name': 'Dashboard', 'href': '/dashboard'},
		// {'name': 'Profile', 'href': '/profile'},
		// {'name': 'Help', 'href': '/help'},
		// {'name': 'Logout', 'href': '/logout'},
	];

	return (
		<Navbar onMenuOpenChange={setIsMenuOpen}>
			<NavbarContent>
				<NavbarMenuToggle
					aria-label={isMenuOpen ? "Close menu" : "Open menu"}
					className="sm:hidden"
				/>
				<NavbarBrand>
					<Link href="/"><AcmeLogo /></Link>
					{/* <p className="font-bold text-inherit">ACME</p> */}
				</NavbarBrand>
			</NavbarContent>

			<NavbarContent className="hidden sm:flex gap-4" justify="center">
				<NavbarItem>
					{/* <Link color="foreground" href={item.href} key={`${item.name}-${index}`}> */}
					{chattitle}
					{/* </Link> */}
				</NavbarItem>

			</NavbarContent>
			<NavbarContent justify="end">
				{/* <NavbarItem className="hidden lg:flex">
					<Link href="#">Login</Link>
				</NavbarItem> */}
				<NavbarItem>
					<Button as={Link} color="primary" href="/settings" variant="bordered">
						Settings
					</Button>
				</NavbarItem>
			</NavbarContent>
			<NavbarMenu>
				{menuItems.map((item, index) => (
					<NavbarMenuItem key={`${item.name}-${index}`}>
						<Link
							className="w-full"
							color={
								index === 2 ? "primary" : index === menuItems.length - 1 ? "danger" : "foreground"
							}
							href="#"
							size="lg"
						>
							{item.name}
						</Link>
					</NavbarMenuItem>
				))}
			</NavbarMenu>
		</Navbar>
	);
}








//app/helpers/chatHelpers.js
export const API_KEY_STORAGE_KEY = "geminiApiKey";
export const MODEL_STORAGE_KEY = "geminiModel";

export const DEFAULT_MESSAGES = [
	{
		role: "user",
		content:
			"You are Swift,\n a highly efficient and straightforward AI assistant. Your primary goal is to provide quick, accurate, and concise responses to user queries. You are designed to handle a wide range of tasks with precision and speed. Here are your key characteristics:1. **Efficient**: Always aim to complete tasks in the shortest time possible without compromising accuracy.2. **Straightforward**: Provide clear and direct answers. Avoid unnecessary details and get straight to the point.3. **Versatile**: Capable of handling various types of queries and tasks, from scheduling to information retrieval.4. **Professional**: Maintain a professional tone, ensuring that your responses are respectful and appropriate for all users.5. **Accurate**: Ensure that all information provided is correct and up-to-date.6. **User-Focused**: Prioritize the user\"s needs and preferences, adapting your responses to best suit their requirements.Remember, your goal is to be the ultimate no-nonsense assistant, delivering results efficiently and effectively."
	},
	{
		role: "model",
		content: "Hi, **I am Swift**, your efficient and straightforward AI assistant. How can I assist you today?"
	}
];

// Helper utilities for chat scroll behaviour
export function updateHasScrollbar(el, setHasScrollbar, setIsAtTop) {
	if (!el || !setHasScrollbar) return;
	const has = el.scrollHeight > el.clientHeight;
	setHasScrollbar(has);
	if (setIsAtTop) setIsAtTop(el.scrollTop <= 0);
}

export function createScrollHandler(el, setIsAtTop) {
	if (!el || !setIsAtTop) return () => { };
	return function onScroll() {
		setIsAtTop(el.scrollTop <= 0);
	};
}

export function setupResizeObserver(el, cb) {
	if (!el || typeof ResizeObserver === "undefined" || !cb) return null;
	const ro = new ResizeObserver(cb);
	ro.observe(el);
	return ro;
}

export function scrollToTop(el, hasScrollbar, setIsAtTop) {
	if (!el) return;
	if (!hasScrollbar) return;
	el.scrollTo({ top: 0, behavior: "smooth" });
	if (setIsAtTop) setIsAtTop(true);
}














"use client";
// Settings Page for Gemini Next Application
//app/settings/page.jsx
import { useState, useEffect } from "react";
import { TbPrompt } from "react-icons/tb";
import Image from "next/image";
import { Input, Button, Card, addToast, Textarea } from "@heroui/react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import NavbarComponent from "../components/Navbar";
export default function SettingsPage() {
  const router = useRouter();

  const [apiKey, setApiKey] = useState("");
  const [systemPrompt, setSystemPrompt] = useState("");
  const [selectedModel, setSelectedModel] = useState("gemini-2.5-flash-lite"); // Default model
  const [mounted, setMounted] = useState(false);

  // Load data from localStorage on mount
  useEffect(() => {
    const storedApiKey = localStorage.getItem("geminiApiKey") || "";
    setApiKey(storedApiKey);

    const storedSystemPrompt = localStorage.getItem("systemPrompt") || "";
    setSystemPrompt(storedSystemPrompt);

    const storedSelectedModel = localStorage.getItem("selectedModel") || "gemini-2.5-flash-lite";
    setSelectedModel(storedSelectedModel);

    setMounted(true);
  }, []);

  // Handlers for API Key
  const handleApiKeyChange = (e) => {
    const value = e.target.value;
    setApiKey(value);
    if (typeof window !== "undefined") {
      localStorage.setItem("geminiApiKey", value);
    }
  };

  const handleSaveApiKey = () => {
    addToast({
      title: "API Key Saved",
      color: "success",
      description: "Gemini API key saved to local storage.",
    });
  };

  const handleClearApiKey = () => {
    setApiKey("");
    if (typeof window !== "undefined") {
      localStorage.removeItem("geminiApiKey");
    }
    addToast({
      title: "API Key Removed",
      color: "warning",
      description: "Gemini API key removed from local storage.",
    });
  };

  // Handlers for System Prompt
  const handleSystemPromptChange = (e) => {
    const value = e.target.value;
    setSystemPrompt(value);
    if (typeof window !== "undefined") {
      localStorage.setItem("systemPrompt", value);
    }
  };

  const handleTestPrompt = () => {
    // Placeholder for actual prompt testing logic
    addToast({
      title: "Prompt Test Initiated",
      color: "success",
      description: "This feature is under development.",
    });
  };

  const handleClearPrompt = () => {
    setSystemPrompt("");
    if (typeof window !== "undefined") {
      localStorage.removeItem("systemPrompt");
    }
    addToast({
      title: "System Prompt Cleared",
      color: "warning",
      description: "System prompt cleared from local storage.",
    });
  };

  // Handlers for Model Configuration
  const handleModelChange = (e) => {
    const value = e.target.value;
    setSelectedModel(value);
    if (typeof window !== "undefined") {
      localStorage.setItem("selectedModel", value);
    }
  };

  const handleApplyModelConfig = () => {
    addToast({
      title: "Model Configuration Applied",
      color: "success",
      description: "Your model settings have been updated.",
    });
  };

  const handleResetModelConfig = () => {
    setSelectedModel("gemini-pro"); // Reset to default
    if (typeof window !== "undefined") {
      localStorage.setItem("selectedModel", "gemini-pro");
    }
    addToast({
      title: "Model Configuration Reset",
      color: "warning",
      description: "Model settings have been reset to default.",
    });
  };

  return (
    <>
      <NavbarComponent />
      <div className="p-8 bg-base-200 min-h-screen">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 max-w-7xl mx-auto">
          {/* System Prompt Section */}
          <div className="lg:col-span-1 row-span-1 lg:row-span-2 flex flex-col">
            <Card className="flex-1 bg-base-100 rounded-xl p-6 flex flex-col gap-4">
              <div className="flex justify-between items-center">
                <div className="flex flex-col">
                  <h3 className="text-2xl font-semibold">System Prompt</h3>
                  <p className="text-sm text-base-content/60">
                    Set your system prompt to tailor fit model responses according to your requirements.
                  </p>
                </div>
                <TbPrompt size={32} className="text-primary" />
              </div>
              <div className="grow">
                <Textarea
                  placeholder="Enter your system prompt here..."
                  value={systemPrompt}
                  onChange={handleSystemPromptChange}
                  className="w-full h-full resize-none rounded-lg p-4"
                />
              </div>
              <div className="flex flex-row gap-3">
                <Button onPress={handleTestPrompt} className="btn-primary">Test Prompt</Button>
                <Button onPress={handleClearPrompt} className="btn-outline">Clear Prompt</Button>
              </div>
            </Card>
          </div>

          {/* API Key Settings Section (Top Card) */}
          <div className="lg:col-span-1 row-span-1">
            <Card className="w-full bg-base-100 rounded-xl p-6">
              <h2 className="text-2xl font-semibold mb-4">API Key Settings</h2>
              <p className="text-sm text-base-content/60 mb-6">
                Set your Gemini API key below. This value is stored locally in your browser.
              </p>
              <div className="mb-4">
                <label className="block text-sm font-medium mb-2">Gemini API Key</label>
                <Input
                  placeholder="Enter Gemini API key"
                  value={apiKey}
                  onChange={handleApiKeyChange}
                  className="w-full text-black"
                  type="password" // Mask the API key
                />
              </div>
              <div className="flex gap-3">
                <Button onPress={handleSaveApiKey} className="btn-primary" disabled={!mounted}>
                  Save
                </Button>
                <Button onPress={handleClearApiKey} color="danger" className="btn-outline" disabled={!mounted}>
                  Clear
                </Button>
              </div>
            </Card>
          </div>

          {/* Model Configuration Section (Bottom Card) */}
          <div className="lg:col-span-1 row-span-1">
            <Card className="w-full bg-base-100 rounded-xl p-6">
              <h2 className="text-2xl font-semibold mb-4">Model Configuration</h2>
              <p className="text-sm text-base-content/60 mb-6">
                Configure your preferred model and its parameters.
              </p>
              <div className="mb-4">
                <label className="block text-sm font-medium mb-2">Select Model</label>
                <Input
                  placeholder="e.g., gemini-pro"
                  value={selectedModel}
                  onChange={handleModelChange}
                  className="w-full text-content1"
                />
              </div>
              <div className="flex gap-3">
                <Button onPress={handleApplyModelConfig} className="btn-primary">Apply</Button>
                <Button onPress={handleResetModelConfig} className="btn-outline">Reset</Button>
              </div>
            </Card>
          </div>
        </div>
      </div>
    </>
  );
}













// app/layout.jsx
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

import { Providers } from "./providers";
const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata = {
  title: "Gemini Chatbot using Next.js",
  description: "Gemini frontend using Next.js and HeroUI with customizable system prompts.",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers themeProps={{ attribute: "class", defaultTheme: "dark" }}>
          {children}</Providers>
      </body>
    </html>

  );
}














"use client";
// app/page.jsx
import { MdSend } from "react-icons/md";
import { motion, AnimatePresence } from "framer-motion";
import { useState, useRef, useEffect } from "react";
import { LuClipboardPaste } from "react-icons/lu";
import { addToast, Textarea } from "@heroui/react";
import { useRouter } from "next/navigation";
import ReactMarkdown from "react-markdown";
import NavbarComponent from "./components/Navbar";
import { CiCircleChevUp } from "react-icons/ci";
import { v4 as uuidv4 } from 'uuid';
// Added import from helper file (including constants)
import {
	updateHasScrollbar,
	createScrollHandler,
	setupResizeObserver,
	scrollToTop as helperScrollToTop,
	DEFAULT_MESSAGES,
	API_KEY_STORAGE_KEY, MODEL_STORAGE_KEY
} from "./helpers/chatHelpers";

export default function Page() {
	const router = useRouter();
	const [messages, setMessages] = useState(DEFAULT_MESSAGES);
	const [input, setInput] = useState("");
	const [model, setModel] = useState("gemini-2.5-flash");
	const [firstMessageSent, setFirstMessageSent] = useState(false);
	const [loading, setLoading] = useState(false);
	const messagesRef = useRef(null);
	const [hasScrollbar, setHasScrollbar] = useState(false);
	const [isAtTop, setIsAtTop] = useState(true);
	const [chatTitle, setChatTitle] = useState("");
	const [currentChatId, setCurrentChatId] = useState('');
	const scrollToTop = () => {
		helperScrollToTop(messagesRef.current, hasScrollbar, setIsAtTop);
	};

	// New helper: calls /api/title with API key and message passed in the JSON body, returns chat title
	const fetchChatTitle = async (apiKey, message) => {
		try {
			const res = await fetch("/api/title", {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({ message, apiKey })
			});
			if (!res.ok) {
				const txt = await res.text();
				throw new Error(txt || `Status ${res.status}`);
			}
			const data = await res.json();
			return data.chatTitle || data.title || null;
		} catch (e) {
			console.error("fetchChatTitle error:", e);
			return null;
		}
	};

	useEffect(() => {
		if (messagesRef.current) {
			setTimeout(() => {
				messagesRef.current.scrollTop = messagesRef.current.scrollHeight;
				updateHasScrollbar(messagesRef.current, setHasScrollbar, setIsAtTop);
			}, 0);
		}
	}, [messages]);

	// Modified: observe size changes, window resize and scroll to keep detection accurate
	useEffect(() => {
		const el = messagesRef.current;
		if (!el) return;

		// create stable callbacks for listeners so cleanup works
		const resizeCb = () => updateHasScrollbar(el, setHasScrollbar, setIsAtTop);
		const onScroll = createScrollHandler(el, setIsAtTop);

		// Use helper to setup ResizeObserver when available
		let ro = setupResizeObserver(el, resizeCb);
		// attach scroll listener
		el.addEventListener("scroll", onScroll);

		// Also listen to window resize as a fallback
		window.addEventListener("resize", resizeCb);

		// cleanup
		return () => {
			el.removeEventListener("scroll", onScroll);
			if (ro && ro.disconnect) ro.disconnect();
			window.removeEventListener("resize", resizeCb);
		};
	}, []);
	
	const sendMessage = async () => {
		const geminiModel = typeof window !== "undefined" ? localStorage.getItem(MODEL_STORAGE_KEY) : 'gemini-2.5-flash-lite';
		if (!firstMessageSent) {
			// mark as sent immediately so we don't block subsequent sends
			setFirstMessageSent(true);

			// fire off title fetch in background (do NOT await)
			const key = typeof window !== "undefined" ? localStorage.getItem(API_KEY_STORAGE_KEY) : null;
			if (key && input.trim()) {
				fetchChatTitle(key, input)
					.then((title) => {
						if (title) setChatTitle(title);
					})
					.catch((e) => {
						console.error("Error fetching title:", e);
					});
			}
		}


		if (!input.trim()) return;

		const newMessages = [
			...messages,
			{ role: "user", content: input }
		];

		setMessages(newMessages);
		setInput("");
		setLoading(true);

		// Check for stored API key using constant
		const cat = typeof window !== "undefined" ? localStorage.getItem(API_KEY_STORAGE_KEY) : null;
		if (!cat) {
			// show toast and redirect to settings
			addToast({
				title: "API Key Missing",
				description: "Please add your Gemini API key in Settings.",
				color: "warning",
			});
			router.push("/settings");
			setLoading(false);
			return;
		}

		try {
			console.log("Sending messages:", newMessages);
			console.log("geminiModel : ", geminiModel);
			const res = await fetch("/api/chat", {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
					"x-gemini-api-key": cat
				},
				body: JSON.stringify({ messages: newMessages, model: geminiModel })
			});
			console.log("Response status:", res.status);
			const data = await res.json();
			console.log("Response data:", data.error);
			if (data.reply) {
				setMessages(prev => [
					...prev,
					{ role: "model", content: data.reply }
				]);
			}
			if (data.error) {
				setMessages(prev => [
					...prev,
					{ role: "model", content: data.error }
				]);
			}
		} catch (e) {
			console.log(e);
			setMessages(prev => [
				...prev,
				{ role: "model", content: 'error' }
			]);
		}

		setLoading(false);
	};
	const copyContent = (content) => () => {
		navigator.clipboard.writeText(content);
		addToast({
			title: "Copied to Clipboard",
			description: "Content has been copied to clipboard.",
			color: "success",
		});
	};

	return (
		<div className="flex flex-col h-screen bg-base-200">
			{/* HEADER */}
			<NavbarComponent chattitle={chatTitle} />
			{ /* Render the scroll-to-top button only when a scrollbar exists AND we are not already at top */}
			{chatTitle && (
				<AnimatePresence>
					<motion.div
						key="chat-header"
						initial={{ opacity: 0, y: -20 }}
						animate={{ opacity: 1, y: 0 }}
						exit={{ opacity: 0, y: -20 }}
						transition={{ duration: 0.3, ease: "easeOut" }}
						className="w-full overflow-clip font-bold bg-cyan-950 flex flex-row justify-between items-center text-content1 sm:hidden h-[4em] p-6"
					>
						{/* show only first 30 characters */}
						<p>{chatTitle.slice(0, 40)}
							{chatTitle.length > 40 ? "..." : ""}
						</p>
						<AnimatePresence>
							{hasScrollbar && !isAtTop && (
								<motion.div
									key="scroll-top"
									initial={{ opacity: 0, y: 8 }}
									animate={{ opacity: 1, y: 0 }}
									exit={{ opacity: 0, y: -8 }}
									transition={{ duration: 0.18 }}
									className="flex items-center"
								>
									<CiCircleChevUp
										className="cursor-pointer"
										size={38}
										title="Scroll to top"
										role="button"
										tabIndex={0}
										onClick={scrollToTop}
									/>
								</motion.div>
							)}
						</AnimatePresence>
					</motion.div>
				</AnimatePresence>
			)}

			{/* CHAT AREA */}
			<div ref={messagesRef} className="flex-1 overflow-y-auto space-y-4 px-2 md:px-24">
				{messages.slice(1).map((msg, index) => (

					<div key={index} className={`chat gap-0 md:gap-1.5 ${msg.role === "user" ? "chat-end " : "chat-start"
						}`}>
						{msg.role === "model" && (
							<div className="chat-image avatar">
								<div className="w-5 md:w-10 rounded-full">
									<img
										onClick={copyContent(msg.content)}
										alt="Tailwind CSS chat bubble component"
										src="gemini_logo.png"
									/>
								</div>
							</div>
						)}
						{msg.role === "user" && (
							<div className="chat-image avatar">
								<div className="w-5 md:w-10 rounded-full border border-white md:p-2 p-1">
									<img
										alt="Tailwind CSS chat bubble component"
										className=""
										onClick={copyContent(msg.content)}
										src="./user.png"
										//invert the colors of the image
										style={{ filter: "invert(1)" }}
									/>
								</div>
							</div>
						)}

						<AnimatePresence>
							<motion.div
								key={index}
								//if role is user, animate from right, else from left
								initial={{ opacity: 0, x: msg.role === "user" ? 50 : -50 }}
								animate={{ opacity: 1, x: 0, y: 0 }}


								className={`chat-bubble wrap-break-word rounded-4xl   ${msg.role === "user"
									? "bg-primary text-primary-content chat-bubble-info max-w-4/5 md:max-w-3/5 "
									: "  text-black max-w-4/5 md:max-w-3/5 selection:bg-yellow-400  chat-bubble-info"
									}`}
								transition={{ duration: 0.25 }}>
								<ReactMarkdown>
									{msg.content}
								</ReactMarkdown>
								{/* </div> */}
							</motion.div>
						</AnimatePresence>

					</div>
				))}
				<AnimatePresence>
					{
						loading &&

						<div className={`chat chat-start`}>
							<div className="chat-image avatar">
								<div className="w-10 rounded-full">
									<img
										alt="Tailwind CSS chat bubble component"
										src="gemini_logo.png"
									/>
								</div>
							</div>


							<AnimatePresence>
								<motion.div
									//if role is user, animate from right, else from left
									initial={{ opacity: 0, x: -50 }}
									animate={{ opacity: 1, x: 0 }}
									exit={{ opacity: 0, x: 50 }}


									className={`chat-bubble rounded-4xl text-black max-w-4/5 md:max-w-3/5 selection:bg-yellow-400  chat-bubble-info wrap-anywhere`}
									transition={{ duration: 0.25 }}>
									Typing...
								</motion.div>
							</AnimatePresence>

						</div>
					}
				</AnimatePresence>
			</div>

			{/* INPUT BAR */}
			<div className="p-4 flex items-center gap-3 md:px-12">
				{/* <textarea
					className="textarea flex-1 resize-none h-16"
					placeholder="Type prompt..."

					value={input}
					onChange={(e) => setInput(e.target.value)}
					onKeyDown={(e) => {
						if (e.key === "Enter" && !e.shiftKey && !loading) {
							e.preventDefault();
							sendMessage();
						}
					}}
				/> */}
				<Textarea
					label="Prompt"
					variant="flat"
					className="dark"
					onChange={(e) => setInput(e.target.value)}
					value={input}
					maxRows={4}
					placeholder="Enter your prompt..."
					onKeyDown={(e) => {
						//only send message on Enter without Shift
						if (e.key === "Enter" && !e.shiftKey) {
							e.preventDefault();
							if (input.trim() && !loading) {
								sendMessage();
							}
						}
					}}
				/>

				{!input ? (<LuClipboardPaste
					onClick={async () => {
						const text = await navigator.clipboard.readText();
						setInput(text);
					}}
					color="black"
					className="btn rounded-full bg-amber-400 h-14 w-14"
				/>
				) : (
					<MdSend
						disabled={loading}
						color="black"
						className="btn rounded-full bg-amber-400 h-14 w-14"
						onClick={sendMessage}
					/>
				)}



			</div>
		</div>
	);
}















"use client";
// app/providers.jsx
import { ToastProvider } from "@heroui/toast";
import * as React from "react";
import { HeroUIProvider } from "@heroui/system";
import { useRouter } from "next/navigation";



export function Providers({ children, themeProps }) {
  const router = useRouter();

  return (
      <HeroUIProvider navigate={router.push}>
          <ToastProvider placement="top-right" />
          {children}
      </HeroUIProvider>
  );
}



//package.json 


{
  "name": "gemini-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@google/genai": "^1.34.0",
    "@heroui/react": "^2.8.5",
    "autoprefixer": "^10.4.22",
    "dexie": "^4.2.1",
    "framer-motion": "^12.23.25",
    "next": "16.0.8",
    "next-themes": "^0.4.6",
    "postcss": "^8.5.6",
    "react": "19.2.1",
    "react-dom": "19.2.1",
    "react-icons": "^5.5.0",
    "react-markdown": "^10.1.0",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "24.10.2",
    "@types/react": "19.2.7",
    "babel-plugin-react-compiler": "1.0.0",
    "daisyui": "^5.5.9",
    "eslint": "^9",
    "eslint-config-next": "16.0.8",
    "tailwindcss": "^4.1.17"
  }
}

